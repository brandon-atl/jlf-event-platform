# JLF ERP — Cowork Project Context

## What This Project Is
A custom Event Management ERP for Just Love Forest (JLF), a community organization that runs paid events and donation-based retreats. The system bridges Stripe (payments) and Acuity Scheduling (bookings) via webhooks, centralizes data in PostgreSQL, automates reminders for incomplete registrations, and provides dashboards for operators and co-hosts.

## Why It Exists
Brian (primary operator) spends 4-8 hours per event manually reconciling Stripe payments with Acuity bookings in spreadsheets. ~15-20% of attendees fail to complete both steps. Co-hosts have no self-service access to event data. This system eliminates all of that.

## Tech Stack (Decided — Do Not Change)
- **Backend:** Python 3.11+ / FastAPI (async-first)
- **Database:** PostgreSQL via SQLAlchemy 2.0 (async) + Alembic migrations
- **Frontend (MVP):** Streamlit (fastest path; Next.js as Phase 2 upgrade)
- **Hosting:** Railway (managed Postgres, auto-deploy from GitHub)
- **SMS:** Twilio (transactional SMS, pay-as-you-go)
- **Email:** Resend (transactional email, free tier)
- **Auth:** JWT with bcrypt for operators; magic link for co-creators
- **Task Scheduling:** APScheduler for MVP (deferred reminder checks)
- **Deployment:** Docker + GitHub Actions CI/CD

## Core Data Flow
1. Stripe webhook → Backend creates/updates AttendeeEvent (payment_status=PAID)
2. Acuity webhook → Backend creates/updates AttendeeEvent (booking_status=BOOKED)
3. Matching engine: email + event_id as primary key
4. If one-sided after configurable delay → automated reminder email/SMS
5. If both sides complete → overall_status=COMPLETE
6. Dashboard reads from PostgreSQL for real-time operational views

## Key Entities (see reference/DATA_MODEL.md for full schema)
- **Events** — registered once with Acuity + Stripe link IDs
- **Attendees** — deduplicated by email across events
- **AttendeeEvents** — junction table with payment/booking status per event
- **CoCreators** — co-host accounts with event-scoped read-only access
- **NotificationsLog** — audit trail of all sent communications
- **AuditLog** — all state transitions and manual actions

## Attendee States
PAID_ONLY | BOOKED_ONLY | COMPLETE | NEEDS_REVIEW | CANCELLED | REFUNDED

## Critical Requirements
- ALL webhook handlers MUST be idempotent (safe to reprocess on retry)
- Stripe webhooks verified via stripe.Webhook.construct_event()
- Acuity webhooks verified via HMAC signature
- PCI compliance: NEVER store card numbers/CVVs — only payment intent IDs + amounts
- Data encrypted in transit (TLS 1.3) and at rest (managed DB encryption)
- Webhook processing latency target: < 5 seconds end-to-end

## Edge Cases (see reference/EDGE_CASES.md for full matrix)
- Different emails for Stripe vs Acuity → NEEDS_REVIEW state + exception queue
- Group payments → flag + manual assignment by operator
- Duplicate payments → detect via email + event + 24h window → flag
- Walk-ins → manual entry via dashboard
- Refunds → Stripe refund webhook updates status; record retained
- Webhook failures → Stripe auto-retries; dead-letter logging; daily reconciliation cron

## File Structure
- Source code goes in src/backend/app/ and src/frontend/
- Reference docs are in reference/ (READ ONLY — do not modify except SESSION_LOG.md)
- Deployment configs go in deploy/
- Documentation goes in docs/

## Session Protocol
1. START: Read this file + reference/SESSION_LOG.md to understand current state
2. WORK: Build the assigned scope for this session
3. END: Update reference/SESSION_LOG.md and CHANGELOG.md with what was completed
